//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module exp12(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// Seg7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,


	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,


	//////////// PS2 //////////
	inout 		          		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	inout 		          		PS2_DAT2

);
wire [31:0]imemaddr;//cpu给的指令地址，送到指令存储器，因为空间有限，取低16位即可[17:2]
wire [31:0]imemdataout;//32位指令，从指令存储器取出来，送到cpu里面
wire imemclk;//指令存储器的时钟，cpu给出，送到指令存储器
wire [31:0]dmemaddr;//cpu给出数据存储器地址，32位送到数据存储器,数据存储器会做处理，取对应数据
wire [31:0]dmemdataout;//数据存储器给出，送给cpu
wire keyre;
wire [31:0]dmemdatain;//cpu给所有模块的数据，地址前12位对上了才写入

wire dmemrdclk;
wire dmemwrclk;
wire [2:0]dmemop;
wire dmemwe;//cpu给出的we,前12位对上了，取这个，否则为0
wire datawe;//数据存储器的we datawe=(dmemaddr[31:20]==12'h001)?dmemwe:1'b0;
wire vgawe;//vgawe=(dmemaddr[31:20]==12'h002)?dmemwe:1'b0;
wire [7:0]keyboarddata;
wire [7:0] bufferout;
assign VGA_SYNC_N=0;
wire keyboard_CLK;
wire CPU_CLK;
clkgen #(25000000) clkgen_1 (CLOCK_50,1'b0,1'b1,VGA_CLK);
clkgen #(25000) clkgen_2 (CLOCK_50,1'b0,1'b1,CPU_CLK);
clkgen #(30) clkgen_3 (CLOCK_50,1'b0,1'b1,keyboard_CLK);
wire cpu_clk;
reg [31:0] ddata;//这是送给cpu的数据，不一定是数据存储器的数据
wire colorwe;
wire [3:0] color_num;

reg [31:0] time_cnt=0;
always @ (*) begin
	if(dmemaddr[31:20]==12'h001)
		ddata=dmemdataout;
	else if(dmemaddr[31:20]==12'h003)
		ddata=bufferout;
	else if(dmemaddr[31:20]==12'h005)
		ddata=time_cnt;
	else
		ddata=32'b0;
end
////////////////////////////////////////////DEBUG????????????????????????????
assign cpu_clk=CPU_CLK;

reg [7:0]test_buffer;
always @ (*) begin
	if(bufferout!=0)
		test_buffer<=bufferout;
end

//?????????????????????????????????????????????????????????????????????????????????????
assign vgawe=(dmemaddr[31:20]==12'h002)?dmemwe:1'b0;
vga vga_top(
.VGA_CLK(VGA_CLK),
.CLOCK_50(CLOCK_50),
.we(vgawe),
.writedata(dmemdatain[7:0]),
.writeaddress(dmemaddr[11:0]),
.VGA_BLANK_N(VGA_BLANK_N),
.VGA_VS(VGA_VS),
.VGA_HS(VGA_HS),
.VGA_B(VGA_B),
.VGA_G(VGA_G),
.VGA_R(VGA_R),
.color(color_num),
.vga_mem_clk(dmemwrclk),
.vga_offset(vga_offset)
); 

assign keyre=(dmemaddr[31:20]==12'h003)?1'b1:1'b0;
buffer my_buffer(
.keyboarddata(keyboarddata),
.re(keyre),
.bufferout(bufferout),
.rdclk(dmemrdclk),
.clock(CLOCK_50)
);

cpu my_cpu(
.clock(cpu_clk),
.reset(1'b0),
.imemaddr(imemaddr),
.imemdataout(imemdataout),
.imemclk(imemclk),
.dmemaddr(dmemaddr),
.dmemdataout(ddata),
.dmemdatain(dmemdatain),
.dmemrdclk(dmemrdclk),
.dmemwrclk(dmemwrclk),
.dmemop(dmemop),
.dmemwe(dmemwe)
);

keyboard_basic my_keyboard(
.clk(CLOCK_50),
.ps2_clk(PS2_CLK),
.ps2_data(PS2_DAT),
.data(keyboarddata)
);

assign datawe=(dmemaddr[31:20]==12'h001)?dmemwe:1'b0;
mem my_dmem(
.addr(dmemaddr),
.dataout(dmemdataout),
.datain(dmemdatain),
.rdclk(dmemrdclk),
.wrclk(dmemwrclk),
.memop(dmemop),
.we(datawe)
);
	
imem_rom my_imem(
.address(imemaddr[17:2]),
.clock(imemclk),
.q(imemdataout)
);

assign colorwe=(dmemaddr[31:20]==12'h004)?dmemwe:1'b0;
color color_mem(
.we(colorwe),
.wrclk(dmemwrclk),
.wrdata(dmemdatain[3:0]),
.q(color_num)
);


wire second;
clkgen #(1) clkgen_4 (CLOCK_50,1'b0,1'b1,second);
always @ (posedge second) begin
	time_cnt<=time_cnt+1;
end

wire ledwe;
assign ledwe=(dmemaddr[31:20]==12'h006)?dmemwe:1'b0;
reg [9:0] leds [9:0];
always @ (posedge dmemwrclk) begin
	if(ledwe)
		leds[dmemaddr[3:0]][0]<=dmemdatain[0];
end
assign LEDR[0]=leds[0][0];
assign LEDR[1]=leds[1][0];
assign LEDR[2]=leds[2][0];
assign LEDR[3]=leds[3][0];
assign LEDR[4]=leds[4][0];
assign LEDR[5]=leds[5][0];
assign LEDR[6]=leds[6][0];
assign LEDR[7]=leds[7][0];
assign LEDR[8]=leds[8][0];
assign LEDR[9]=leds[9][0];

/*
wire hexwe;
assign hexwe=(dmemaddr[31:20]==12'h007)?dmemwe:1'b0;
reg [7:0] hex [7:0];
always @ (posedge dmemwrclk) begin
	if(hexwe)
		hex[dmemaddr[3:0]][3:0]=dmemdatain[3:0];
end
bcd7seg bcd0(hex[0][3:0],HEX0);
bcd7seg bcd1(hex[1][3:0],HEX1);
bcd7seg bcd2(hex[2][3:0],HEX2);
bcd7seg bcd3(hex[3][3:0],HEX3);
bcd7seg bcd4(hex[4][3:0],HEX4);
bcd7seg bcd5(hex[5][3:0],HEX5);*/

wire vga_offset_we;
assign vga_offset_we=(dmemaddr[31:20]==12'h008)?dmemwe:1'b0;
reg [31:0] vga_offset;
always @ (posedge dmemwrclk) begin
	if(vga_offset_we)
		vga_offset<=dmemdatain;
end
bcd7seg bcd0(vga_offset[3:0],HEX0);
bcd7seg bcd1(vga_offset[7:4],HEX1);
endmodule