//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module exp12(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// Seg7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,


	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,


	//////////// PS2 //////////
	inout 		          		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	inout 		          		PS2_DAT2

);
wire [31:0]imemaddr;//cpu给的指令地址，送到指令存储器，因为空间有限，取低16位即可[17:2]
wire [31:0]imemdataout;//32位指令，从指令存储器取出来，送到cpu里面
wire imemclk;//指令存储器的时钟，cpu给出，送到指令存储器
wire [31:0]dmemaddr;//cpu给出数据存储器地址，32位送到数据存储器,数据存储器会做处理，取对应数据
wire [31:0]dmemdataout;//数据存储器给出，送给cpu
wire keyre;
wire [31:0]dmemdatain;//cpu给所有模块的数据，地址前12位对上了才写入

wire dmemrdclk;
wire dmemwrclk;
wire [2:0]dmemop;
wire dmemwe;//cpu给出的we,前12位对上了，取这个，否则为0
wire datawe;//数据存储器的we datawe=(dmemaddr[31:20]==12'h001)?dmemwe:1'b0;
wire vgawe;//vgawe=(dmemaddr[31:20]==12'h002)?dmemwe:1'b0;
wire [7:0]keyboarddata;
wire [7:0] bufferout;
assign VGA_SYNC_N=0;
wire keyboard_CLK;
wire CPU_CLK;
clkgen #(25000000) clkgen_1 (CLOCK_50,1'b0,1'b1,VGA_CLK);
clkgen #(25000) clkgen_2 (CLOCK_50,1'b0,1'b1,CPU_CLK);
clkgen #(30) clkgen_3 (CLOCK_50,1'b0,1'b1,keyboard_CLK);
wire cpu_clk;
reg [31:0] ddata;//这是送给cpu的数据，不一定是数据存储器的数据
wire colorwe;
wire [3:0] color_num;

reg [31:0] time_cnt=0;
always @ (*) begin
	if(dmemaddr[31:20]==12'h001)
		ddata=dmemdataout;
	else if(dmemaddr[31:20]==12'h003)
		ddata=bufferout;
	else if(dmemaddr[31:20]==12'h005)
		ddata=time_cnt;
	else
		ddata=32'b0;
end
////////////////////////////////////////////DEBUG????????????????????????????
assign LEDR[0]=dmemwe;
assign LEDR[1]=vgawe;
assign LEDR[2]=datawe;
assign cpu_clk=CPU_CLK;
assign LEDR[3]=cpu_clk;
reg [7:0]test_buffer;
always @ (*) begin
	if(bufferout!=0)
		test_buffer<=bufferout;
end
bcd7seg bcd4(time_cnt[3:0],HEX4);
bcd7seg bcd5(time_cnt[7:4],HEX5);

//?????????????????????????????????????????????????????????????????????????????????????
assign vgawe=(dmemaddr[31:20]==12'h002)?dmemwe:1'b0;
vga vga_top(
.VGA_CLK(VGA_CLK),
.CLOCK_50(CLOCK_50),
.we(vgawe),
.writedata(dmemdatain[7:0]),
.writeaddress(dmemaddr[11:0]),
.VGA_BLANK_N(VGA_BLANK_N),
.VGA_VS(VGA_VS),
.VGA_HS(VGA_HS),
.VGA_B(VGA_B),
.VGA_G(VGA_G),
.VGA_R(VGA_R),
.color(color),
.vga_mem_clk(dmemwrclk)
); 

assign keyre=(dmemaddr[31:20]==12'h003)?1'b1:1'b0;
buffer my_buffer(
.HEX2(HEX2),
.HEX3(HEX3),
.keyboarddata(keyboarddata),
.re(keyre),
.bufferout(bufferout),
.rdclk(dmemrdclk),
.clock(CLOCK_50)
);

cpu my_cpu(
.HEX0(HEX0),
.HEX1(HEX1),
.clock(cpu_clk),
.reset(1'b0),
.imemaddr(imemaddr),
.imemdataout(imemdataout),
.imemclk(imemclk),
.dmemaddr(dmemaddr),
.dmemdataout(ddata),
.dmemdatain(dmemdatain),
.dmemrdclk(dmemrdclk),
.dmemwrclk(dmemwrclk),
.dmemop(dmemop),
.dmemwe(dmemwe)
);

keyboard_basic my_keyboard(
.clk(CLOCK_50),
.ps2_clk(PS2_CLK),
.ps2_data(PS2_DAT),
.data(keyboarddata)
);

assign datawe=(dmemaddr[31:20]==12'h001)?dmemwe:1'b0;
mem my_dmem(
.addr(dmemaddr),
.dataout(dmemdataout),
.datain(dmemdatain),
.rdclk(dmemrdclk),
.wrclk(dmemwrclk),
.memop(dmemop),
.we(datawe)
);
	
imem_rom my_imem(
.address(imemaddr[17:2]),
.clock(imemclk),
.q(imemdataout)
);

assign colorwe=(dmemaddr[31:20]==12'h004)?dmemwe:1'b0;
color color_mem(
.we(colorwe),
.wrclk(dmemwrclk),
.wrdata(dmemdatain[3:0]),
.q(color_num)
);


wire second;
clkgen #(1) clkgen_4 (CLOCK_50,1'b0,1'b1,second);
always @ (posedge second) begin
	time_cnt<=time_cnt+1;
end
endmodule